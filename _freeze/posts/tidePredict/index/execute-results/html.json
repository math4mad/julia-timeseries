{
  "hash": "50a0ccda424f2bd14eafbc539c09c69c",
  "result": {
    "markdown": "---\ntitle: coastal tide predict\nauthor: math4mads\ndate: '2023-10-01'\ncategories:\n  - julia\n  - timeseries\nformat:\n  html:\n    code-fold: true\nimage: agp-tide-predict-odm.png\n---\n\n# Tide Predict\n\n:::{.callout-note}\n   - 使用 [AugmentedGaussianProcesses.jl](https://theogf.dev/AugmentedGaussianProcesses.jl/stable/)\n   - AGP  也是高斯过程方法, 在近似的时候可以选取多个初始点来探索概率空间, 适合大规模数据\n   - Tide 数据集参见[`kaggle  tide predict`](https://www.kaggle.com/datasets/arjunbhaybhang/marine-institute-tide-prediction-dataset), 数据解压缩有 400MB,所有没有全部使用,截取了名为\n   **截取了名为Aranmore** 水文站的数据 本仓库 tsData 文件夹中\n:::\n\n\n## 1. load package\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n    include(\"./utils.jl\")\n    using   AugmentedGaussianProcesses\n    using   CSV,TableTransforms,Random\n    using   GLMakie\n```\n:::\n\n\n## 2. load data\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n    df1=load_csv(\"Aranmore-2017-odm\")\n    df2=load_csv(\"Aranmore-2018-odm\")\n    df3=load_csv(\"Aranmore-2019-odm\")\n\n    selected_data=[df[1:200:end,:Water_Level_ODM] for df in [df1,df2,df3]]\n    rows=size(selected_data[1],1)\n    X=[1:rows...].|>Float64\n    y=selected_data[1]|>Vector\n\n    X_train = X[1:2:end];\n    y_train = y[1:2:end]; # We split the data equally\n    X_test = X[2:2:end];\n    y_test = y[2:2:end];\n    display(first(selected_data,10))\n```\n\n::: {.cell-output .cell-output-display}\n```\n3-element Vector{Vector{Float64}}:\n [-1.22, 1.27, -0.85, 0.17, 1.06, -1.06, 0.74, -0.54, 0.1, 0.79  …  -0.81, 0.5, 0.7, -0.73, 0.67, -0.66, 0.41, 0.63, -0.85, 1.46]\n [-1.11, 0.21, 1.08, -1.66, 2.05, -0.46, -0.59, 1.01, -1.17, 1.22  …  0.84, -1.51, 1.93, -0.64, -0.4, 0.77, -1.16, 1.36, -0.3, -0.09]\n [0.32, -0.93, 1.2, -0.52, -0.05, 1.2, -1.34, 0.85, 0.22, -0.91  …  1.5, -0.72, 0.07, 1.2, -1.48, 1.17, -0.11, -0.62, 1.63, -0.78]\n```\n:::\n:::\n\n\n## 3. define AGP model\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n    σ = 0.05\n    Ms = [100,150,200,210];  #选取参考点数\n    models = Vector{AbstractGPModel}(undef, length(Ms));\n\n    function agp(X,y)\n        \n        kernel = SqExponentialKernel()+ PeriodicKernel()\n        for (index, num_inducing) in enumerate(Ms)\n            @info \"Training with $(num_inducing) points\"\n            m = SVGP(\n                kernel, # Kernel\n                GaussianLikelihood(σ), # Likelihood used\n                AnalyticVI(), # Inference usede to solve the problem\n                inducingpoints(KmeansAlg(num_inducing), X); # Inducing points initialized with kmeans\n                optimiser=false, # Keep kernel parameters fixed\n                Zoptimiser=false, # Keep inducing points locations fixed\n            )\n            @time train!(m, X, y, 100) # Train the model for 100 iterations\n            models[index] = m # Save the model in the array\n        end\n    end\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nagp (generic function with 1 method)\n```\n:::\n:::\n\n\n## 4. define plot function \n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n    function plot_models(models)\n\n        fig=Figure(resolution=(2800,1200))\n\n        for (idx,model) in enumerate(models)\n            y_grid, sig_y_grid = proba_y(model, X_test)\n            local ax1=Axis(fig[idx,1],title=\"M=$(Ms[idx])\",titlealign = :left)\n            scatter!(ax1,X_train,y_train,marker=:circle,markersize=10,color=(:lightgreen,0.2),strokewidth=1,strokecolor=:black)\n            σ_arr=sqrt.(sig_y_grid)\n            band!(ax1,X_test,y_grid-σ_arr,y_grid+σ_arr,color=(:red,0.6))\n            \n        end\n        \n        fig\n        #save(\"agp-tide-predict-odm-2.png\",fig)\n    end\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nplot_models (generic function with 1 method)\n```\n:::\n:::\n\n\n## 5.  evlaute model and plot results\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n    agp(X_train,y_train)\n    plot_models(models)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n[ Info: Training with 100 points\n[ Info: Training with 150 points\n[ Info: Training with 200 points\n[ Info: Training with 210 points\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.113034 seconds (77.73 k allocations: 139.970 MiB, 20.12% gc time)\n  0.202329 seconds (124.53 k allocations: 268.146 MiB, 8.24% gc time)\n  0.351548 seconds (181.33 k allocations: 435.561 MiB, 8.37% gc time)\n  0.349434 seconds (193.89 k allocations: 473.747 MiB, 9.18% gc time)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=13}\n![](index_files/figure-html/cell-6-output-3.png){}\n:::\n:::\n\n\n## 6. 结论\n\n:::{.callout-note title=\"Results\"}\n 潮汐的的 timeseries里只看到周期性的趋势, 没有线性趋势\n 由于统计数据的数据点非常多, 多以需要的探索点也很多200多\n 点才能得到比较好的拟合曲线, 这是因为数据自身的维度就很高\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}